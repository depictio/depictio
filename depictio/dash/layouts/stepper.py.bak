import dash
import dash_ag_grid as dag
import dash_mantine_components as dmc
import httpx
from dash import ALL, MATCH, Input, Output, State, callback, ctx, html
from dash_iconify import DashIconify

# Depictio imports
from depictio.api.v1.configs.config import API_BASE_URL
from depictio.api.v1.configs.logging_init import logger
from depictio.api.v1.deltatables_utils import load_deltatable_lite

# Stepper parts imports
from depictio.dash.layouts.stepper_parts.part_one import register_callbacks_stepper_part_one
from depictio.dash.layouts.stepper_parts.part_three import register_callbacks_stepper_part_three
from depictio.dash.layouts.stepper_parts.part_two import register_callbacks_stepper_part_two
from depictio.dash.modules.card_component.frontend import design_card
from depictio.dash.modules.figure_component.frontend import design_figure
from depictio.dash.modules.interactive_component.frontend import design_interactive

min_step = 0
max_step = 3
active = 0


def _get_ag_grid_theme_class(theme: str) -> str:
    """Get the appropriate AG Grid theme class based on the theme.

    Args:
        theme: Theme name ("light", "dark", or other)

    Returns:
        AG Grid CSS theme class name
    """
    # Handle case where theme is empty dict, None, or other falsy value
    if not theme or theme == {} or theme == "{}":
        theme = "light"

    logger.debug(f"STEPPER - Using theme: {theme} for AG Grid")
    return "ag-theme-alpine-dark" if theme == "dark" else "ag-theme-alpine"


def register_callbacks_stepper(app):
    # Register callbacks from modular parts
    register_callbacks_stepper_part_one(app)
    register_callbacks_stepper_part_two(app)
    register_callbacks_stepper_part_three(app)

    @app.callback(
        Output({"type": "modal", "index": MATCH}, "opened"),
        [Input({"type": "btn-done", "index": MATCH}, "n_clicks")],
        prevent_initial_call=True,
    )
    def handle_modal_close(n_clicks):
        """Close modal when btn-done is clicked."""
        if not n_clicks or n_clicks == 0:
            return dash.no_update

        logger.info(f"ðŸ”§ BTN-DONE: Closing modal for n_clicks={n_clicks}")
        return False

    # Separate callback for component creation using ALL pattern to match global output
    @app.callback(
        Output("sections-container", "children", allow_duplicate=True),
        [Input({"type": "btn-done", "index": ALL}, "n_clicks")],
        [
            State({"type": "workflow-selection-label", "index": ALL}, "value"),
            State({"type": "datacollection-selection-label", "index": ALL}, "value"),
            State("local-store", "data"),
            State("sections-container", "children"),
        ],
        prevent_initial_call=True,
    )
    def handle_component_creation_all(n_clicks_list, wf_values, dc_values, local_data, current_sections):
        """Create component when btn-done is clicked - using ALL pattern."""
        # Check if any btn-done was clicked
        if not n_clicks_list or not any(n_clicks_list) or all(n is None or n == 0 for n in n_clicks_list):
            return dash.no_update

        logger.info(f"ðŸ”§ BTN-DONE: COMPONENT CREATION ALL callback triggered with n_clicks_list={n_clicks_list}")
        logger.info(f"ðŸ”§ BTN-DONE: wf_values={wf_values}, dc_values={dc_values}")

        # Find which button was clicked and get corresponding values
        clicked_index = None
        for i, n_clicks in enumerate(n_clicks_list):
            if n_clicks and n_clicks > 0:
                clicked_index = i
                break

        if clicked_index is None:
            return dash.no_update

        wf_value = wf_values[clicked_index] if clicked_index < len(wf_values) else None
        dc_value = dc_values[clicked_index] if clicked_index < len(dc_values) else None

        logger.info(f"ðŸ”§ BTN-DONE: Using values from index {clicked_index}: wf={wf_value}, dc={dc_value}")

        # Create component and add to sections
        try:
            # Use real values or fallback to dummy for testing
            if not wf_value or not dc_value:
                wf_value = "dummy_workflow_for_testing"
                dc_value = "dummy_datacollection_for_testing"
                logger.info("ðŸ”§ BTN-DONE: Using dummy values for component creation")

            # Generate component ID
            import uuid
            component_id = str(uuid.uuid4())

            # Create demo component
            from datetime import datetime
            import dash_mantine_components as dmc
            from dash import html

            built_component = dmc.Paper(
                children=[
                    dmc.Title("Demo Component", order=4),
                    dmc.Text("This is a test component created via minimal stepper", size="sm"),
                    dmc.Badge(f"ID: {component_id[:8]}", color="blue"),
                    dmc.Text(f"Created: {datetime.now().strftime('%H:%M:%S')}", size="xs", c="gray"),
                ],
                p="md",
                radius="md",
                withBorder=True,
                style={
                    "backgroundColor": "var(--app-surface-color, #ffffff)",
                    "color": "var(--app-text-color, #000000)",
                    "border": "2px solid var(--mantine-color-blue-6)",
                }
            )

            # Add to sections
            current_sections = current_sections or []
            section_count = len([
                s for s in current_sections
                if isinstance(s, dict) and s.get("props", {}).get("id", "").startswith("section-")
            ])

            section_letter = chr(65 + section_count)  # A, B, C, etc.

            new_section = dmc.Paper(
                id=f"section-{section_count}",
                children=[
                    dmc.Group([
                        dmc.Text("ðŸ“Š", size="lg"),
                        dmc.Text(f"#{section_count + 1}", w=700, c="blue"),
                        dmc.Text(f"Section {section_letter} - Demo", size="lg"),
                    ], justify="flex-start", align="center", gap="xs"),
                    dmc.Text(f"Section ID: section-{section_count}", size="xs", c="gray",
                            style={"marginTop": "0.5rem"}),
                    html.Div([
                        dmc.Text("Built Component:", fw="bold", size="sm",
                                style={"marginTop": "1rem"}),
                        built_component,
                    ], style={"marginTop": "1rem"}),
                ],
                p="md", radius="md", withBorder=True,
                style={
                    "marginBottom": "0.5rem",
                    "backgroundColor": "var(--app-surface-color, #ffffff)",
                    "color": "var(--app-text-color, #000000)",
                    "border": "1px solid var(--app-border-color, #ddd)",
                },
            )

            # Update sections
            if section_count == 0:
                updated_sections = [new_section]
            else:
                updated_sections = current_sections + [new_section]

            logger.info(f"ðŸ”§ BTN-DONE: Successfully created Section {section_letter} with demo component")
            return updated_sections

        except Exception as e:
            logger.error(f"ðŸ”§ BTN-DONE: Error creating component: {e}")
            return dash.no_update

    # DISABLED: Duplicate callback for component creation and section update
    # This callback conflicts with handle_component_creation_all above
    """
    @app.callback(
        Output("sections-container", "children", allow_duplicate=True),
        [Input({"type": "btn-done", "index": ALL}, "n_clicks")],
        [
            State({"type": "workflow-selection-label", "index": ALL}, "value"),
            State({"type": "datacollection-selection-label", "index": ALL}, "value"),
            State("local-store", "data"),
            State("sections-container", "children"),
        ],
        prevent_initial_call=True,
    )
    def handle_component_creation_with_section(
        n_clicks_list, wf_values, dc_values, local_data, current_sections
    ):
        """Enhanced component creation: build component and add to new section."""
        logger.info("ðŸ”§ BTN-DONE CALLBACK: ===== COMPONENT CREATION STARTED =====")
        logger.info(f"ðŸ”§ BTN-DONE CALLBACK: n_clicks_list={n_clicks_list}")
        logger.info(f"ðŸ”§ BTN-DONE CALLBACK: wf_values={wf_values}")
        logger.info(f"ðŸ”§ BTN-DONE CALLBACK: dc_values={dc_values}")
        logger.info(f"ðŸ”§ BTN-DONE CALLBACK: local_data keys={list(local_data.keys()) if local_data else 'None'}")
        logger.info(f"ðŸ”§ BTN-DONE CALLBACK: current_sections count={len(current_sections) if current_sections else 0}")

        # Check if any btn-done was clicked
        if not n_clicks_list:
            logger.info("ðŸ”§ BTN-DONE CALLBACK: n_clicks_list is empty")
            return dash.no_update

        if not any(n_clicks_list) or all(n is None or n == 0 for n in n_clicks_list):
            logger.info("ðŸ”§ BTN-DONE CALLBACK: No valid clicks detected, returning no_update")
            return dash.no_update

        # Import required modules
        from depictio.dash.component_metadata import get_build_functions

        logger.info("ðŸ”§ BTN-DONE: Enhanced component creation triggered")

        # Find which button was clicked and get corresponding values
        clicked_index = None
        for i, n_clicks in enumerate(n_clicks_list):
            if n_clicks and n_clicks > 0:
                clicked_index = i
                logger.info(f"ðŸ”§ BTN-DONE: Found clicked button at index {i} with {n_clicks} clicks")
                break

        if clicked_index is None:
            logger.warning("ðŸ”§ BTN-DONE: No valid clicked button found")
            return dash.no_update

        wf_value = wf_values[clicked_index] if clicked_index < len(wf_values) else None
        dc_value = dc_values[clicked_index] if clicked_index < len(dc_values) else None

        logger.info(f"ðŸ”§ BTN-DONE: Extracted wf_value={wf_value}, dc_value={dc_value}")

        # ENHANCED: Provide default values for minimal testing if missing
        if not wf_value or not dc_value:
            logger.warning("ðŸ”§ BTN-DONE: Missing workflow or datacollection values, using defaults for testing")

            # Try to get any available workflow/datacollection from project
            try:
                TOKEN = local_data.get("access_token") if local_data else None
                if TOKEN:

                    # Get current pathname to extract dashboard_id
                    # For minimal testing, use dummy values
                    wf_value = "dummy_workflow_for_testing"
                    dc_value = "dummy_datacollection_for_testing"
                    logger.info(f"ðŸ”§ BTN-DONE: Using dummy values: wf={wf_value}, dc={dc_value}")
                else:
                    logger.error("ðŸ”§ BTN-DONE: No access token available, cannot create component")
                    return dash.no_update
            except Exception as e:
                logger.error(f"ðŸ”§ BTN-DONE: Error getting default values: {e}")
                return dash.no_update

        # Generate a component ID for this creation
        import uuid
        component_id = str(uuid.uuid4())

        # Build the component using build_* utils
        try:
            logger.info("ðŸ”§ BTN-DONE: Starting component building process")

            # For minimal testing, create a simple demo component instead of complex build_* logic
            if wf_value == "dummy_workflow_for_testing" or dc_value == "dummy_datacollection_for_testing":
                logger.info("ðŸ”§ BTN-DONE: Creating simple demo component for testing")

                # Create a simple demo component
                from datetime import datetime

                import dash_mantine_components as dmc
                from dash import html

                built_component = dmc.Paper(
                    children=[
                        dmc.Title("Demo Component", order=4),
                        dmc.Text("This is a test component created via minimal stepper", size="sm"),
                        dmc.Badge(f"ID: {component_id[:8]}", color="blue"),
                        dmc.Text(f"Created: {datetime.now().strftime('%H:%M:%S')}", size="xs", c="gray"),
                    ],
                    p="md",
                    radius="md",
                    withBorder=True,
                    style={
                        "backgroundColor": "var(--app-surface-color, #ffffff)",
                        "color": "var(--app-text-color, #000000)",
                        "border": "2px solid var(--mantine-color-blue-6)",
                    }
                )
                logger.info("ðŸ”§ BTN-DONE: Demo component created successfully")

            else:
                # Use real build_* functions for actual workflow/datacollection
                component_metadata = {
                    "index": component_id,
                    "component_type": "card",  # Default to card for now
                    "wf_id": wf_value,
                    "dc_id": dc_value,
                    "stepper": False,  # Not in stepper mode when adding to dashboard
                    "build_frame": True,
                    "refresh": True,
                    "access_token": local_data.get("access_token") if local_data else None,
                    "no_store": True,
                    "theme": "light",
                }

                # Get build functions and build the component
                helpers_mapping = get_build_functions()
                comp_type = component_metadata["component_type"]

                if comp_type in helpers_mapping:
                    logger.info(f"ðŸ”§ BTN-DONE: Building {comp_type} component with build_* utils")
                    built_component = helpers_mapping[comp_type](**component_metadata)
                    logger.info(f"ðŸ”§ BTN-DONE: Component built successfully: {type(built_component)}")
                else:
                    logger.error(f"ðŸ”§ BTN-DONE: Component type {comp_type} not found in helpers_mapping")
                    return dash.no_update

            # Add component to a new section
            current_sections = current_sections or []
            logger.info(f"ðŸ”§ BTN-DONE: Current sections before adding: {len(current_sections)}")

            # Count existing sections (excluding welcome message)
            section_count = len(
                [
                    s
                    for s in current_sections
                    if isinstance(s, dict)
                    and s.get("props", {}).get("id", "").startswith("section-")
                ]
            )

            # Create new section with the built component
            section_letter = chr(65 + section_count)  # A, B, C, etc.
            comp_type = "demo" if wf_value == "dummy_workflow_for_testing" else "card"

            # Create section that contains the actual built component
            import dash_mantine_components as dmc
            from dash import html

            new_section = dmc.Paper(
                id=f"section-{section_count}",
                children=[
                    dmc.Group(
                        [
                            dmc.Text("ðŸ“Š", size="lg"),
                            dmc.Text(f"#{section_count + 1}", w=700, c="blue"),
                            dmc.Text(
                                f"Section {section_letter} - {comp_type.title()}", size="lg"
                            ),
                        ],
                        justify="flex-start",
                        align="center",
                        gap="xs",
                    ),
                    dmc.Text(
                        f"Section ID: section-{section_count}",
                        size="xs",
                        c="gray",
                        style={"marginTop": "0.5rem"},
                    ),
                    # Add the actual built component here
                    html.Div(
                        [
                            dmc.Text(
                                "Built Component:",
                                fw="bold",
                                size="sm",
                                style={"marginTop": "1rem"},
                            ),
                                built_component,  # This is the actual rendered component
                            ],
                            style={"marginTop": "1rem"},
                        ),
                    ],
                    p="md",
                    radius="md",
                    withBorder=True,
                    style={
                        "marginBottom": "0.5rem",
                        "backgroundColor": "var(--app-surface-color, #ffffff)",
                        "color": "var(--app-text-color, #000000)",
                        "border": "1px solid var(--app-border-color, #ddd)",
                    },
            )

            # Add the new section to sections
            if section_count == 0:
                # Replace welcome message with first section
                updated_sections = [new_section]
            else:
                updated_sections = current_sections + [new_section]

            logger.info(f"ðŸ”§ BTN-DONE: Added built component to Section {section_letter}")
            return updated_sections

        except Exception as e:
            logger.error(f"ðŸ”§ BTN-DONE: Error creating component: {e}")
            return dash.no_update

    # Callback to display component metadata
    @app.callback(
        Output({"type": "component-metadata-display", "index": MATCH}, "children"),
        [
            Input({"type": "workflow-selection-label", "index": MATCH}, "value"),
            Input({"type": "datacollection-selection-label", "index": MATCH}, "value"),
        ],
        [
            State("local-store-components-metadata", "data"),
            State({"type": "component-metadata-display", "index": MATCH}, "id"),
        ],
        prevent_initial_call=True,
    )
    """

    # Callback to display component metadata
    @app.callback(
        Output({"type": "component-metadata-display", "index": MATCH}, "children"),
        [
            Input({"type": "workflow-selection-label", "index": MATCH}, "value"),
            Input({"type": "datacollection-selection-label", "index": MATCH}, "value"),
        ],
        [
            State({"type": "components-metadata", "index": MATCH}, "data"),
            State({"type": "component-metadata-display", "index": MATCH}, "id"),
        ],
        prevent_initial_call=True,
    )
    def display_component_metadata(wf_value, dc_value, components_metadata, component_id_dict):
        """Display component metadata below btn-done button."""
        if not wf_value or not dc_value:
            return html.Div()

        component_id = component_id_dict["index"]

        # Debug: Log the components_metadata structure
        logger.info(f"ðŸ”§ METADATA: Component ID: {component_id}")
        logger.info(f"ðŸ”§ METADATA: Type of components_metadata: {type(components_metadata)}")
        if components_metadata:
            logger.info(f"ðŸ”§ METADATA: Contents: {components_metadata}")
            logger.info(f"ðŸ”§ METADATA: Length: {len(components_metadata)}")
            for i, comp in enumerate(components_metadata):
                logger.info(f"ðŸ”§ METADATA: Item {i}: {comp} (type: {type(comp)})")

        # Find the component metadata for this component_id
        component_metadata = None
        if components_metadata:
            for comp in components_metadata:
                # Handle both dict and string types in components_metadata
                if isinstance(comp, dict):
                    # Remove -tmp logic as requested - just match the component_id directly
                    if (
                        comp.get("index") == component_id
                        or comp.get("index") == f"{component_id}-tmp"
                    ):
                        component_metadata = comp.copy()
                        break
                elif isinstance(comp, str):
                    # If it's a string, skip it for now (might be a different data format)
                    continue

        if not component_metadata:
            # Create basic metadata from current inputs if none found
            logger.info(
                "ðŸ”§ METADATA: No stored metadata found, creating basic metadata from inputs"
            )
            component_metadata = {
                "index": component_id,
                "component_type": "card",  # Default since we're testing card components
                "wf_id": wf_value,
                "dc_id": dc_value,
                "stepper": True,
                "status": "Generated from current inputs (metadata not found in store)",
            }

        # Display the metadata in a readable format
        metadata_items = []
        for key, value in component_metadata.items():
            if key not in ["access_token"]:  # Hide sensitive data
                metadata_items.append(
                    dmc.Group(
                        [
                            dmc.Text(f"{key}:", fw="bold", size="sm"),
                            dmc.Text(str(value), size="sm", c="gray"),
                        ],
                        gap="xs",
                    )
                )

        return dmc.Card(
            [
                dmc.Text("Component Metadata:", fw="bold", size="md", mb="sm"),
                dmc.Stack(metadata_items, gap="xs"),
            ],
            withBorder=True,
            p="md",
            style={"backgroundColor": "#f8f9fa"},
        )

    # Separate callback for URL redirection
    @app.callback(
        Output("url", "pathname", allow_duplicate=True),
        [Input({"type": "btn-done", "index": ALL}, "n_clicks")],
        [State("url", "pathname")],
        prevent_initial_call=True,
    )
    def redirect_after_component_creation(n_clicks_list, current_pathname):
        """Redirect to dashboard after component creation."""
        # Check if any btn-done was clicked
        if not any(n_clicks_list) or all(n is None or n == 0 for n in n_clicks_list):
            return dash.no_update

        logger.info("ðŸ”§ BTN-DONE: Redirecting to dashboard")

        # Extract dashboard_id from URL
        path_parts = current_pathname.strip("/").split("/")
        if len(path_parts) >= 2:
            dashboard_id = path_parts[1]
            redirect_url = f"/dashboard/{dashboard_id}"
            logger.info(f"ðŸ”§ BTN-DONE: Redirecting to {redirect_url}")
            return redirect_url
        else:
            logger.error("ðŸ”§ BTN-DONE: Could not extract dashboard_id from pathname")
            return dash.no_update

    @app.callback(
        Output({"type": "modal-edit", "index": MATCH}, "opened"),
        [
            Input({"type": "btn-done-edit", "index": MATCH}, "n_clicks"),
            Input({"type": "modal-edit", "index": MATCH}, "opened"),
        ],
        prevent_initial_call=True,
    )
    def close_edit_modal(n_clicks, modal_opened):
        if not ctx.triggered:
            return True

        trigger_id = ctx.triggered[0]["prop_id"].split(".")[0]

        # If done button was clicked, close modal
        if "btn-done-edit" in trigger_id:
            if n_clicks and n_clicks > 0:
                logger.info("ðŸ”š EDIT MODAL - Done button clicked, closing modal")
                return False

        # For modal state changes, let the draggable callback handle restoration
        # Just return the current state without interfering
        logger.info(f"ðŸ”š EDIT MODAL - Modal state passthrough: {modal_opened}")
        return modal_opened

    @app.callback(
        Output({"type": "workflow-selection-label", "index": MATCH}, "data"),
        Output({"type": "workflow-selection-label", "index": MATCH}, "value"),
        Input({"type": "btn-option", "index": MATCH, "value": ALL}, "n_clicks"),
        State("local-store", "data"),
        State("url", "pathname"),
        prevent_initial_call=True,
    )
    def set_workflow_options(n_clicks, local_store, pathname):
        logger.info(f"CTX Triggered ID: {ctx.triggered_id}")
        logger.info(f"CTX triggered: {ctx.triggered}")

        if not local_store:
            raise dash.exceptions.PreventUpdate

        TOKEN = local_store["access_token"]

        if isinstance(ctx.triggered_id, dict):
            if ctx.triggered_id["type"] == "btn-option":
                component_selected = ctx.triggered_id["value"]
        else:
            component_selected = "None"

        # Extract dashboard_id from pathname, handling both regular and component creation URLs
        # Regular: /dashboard/{dashboard_id}
        # Component creation: /dashboard/{dashboard_id}/{component_id}/create
        path_parts = pathname.strip("/").split("/")
        if len(path_parts) >= 2:
            dashboard_id = path_parts[1]  # Always the second part
        else:
            dashboard_id = path_parts[-1]  # Fallback to last part

        logger.info(f"ðŸ”„ STEPPER: Extracted dashboard_id: {dashboard_id} from pathname: {pathname}")

        project = httpx.get(
            f"{API_BASE_URL}/depictio/api/v1/projects/get/from_dashboard_id/{dashboard_id}",
            headers={
                "Authorization": f"Bearer {TOKEN}",
            },
        ).json()

        # Handle missing workflows key gracefully
        all_wf_dc = project.get("workflows", [])
        logger.info(f"Project data: {project}")
        logger.info(f"Available workflows: {all_wf_dc}")

        mapping_component_data_collection = {
            "table": ["Figure", "Card", "Interactive", "Table", "Text"],
            "jbrowse2": ["JBrowse2"],
        }

        logger.info(f"Component selected: {component_selected}")

        # Use a dictionary to track unique workflows efficiently
        valid_wfs = []
        seen_workflow_ids = set()

        for wf in all_wf_dc:
            # Check if the workflow has any matching data collection
            if (
                any(
                    component_selected in mapping_component_data_collection[dc["config"]["type"]]
                    for dc in wf["data_collections"]
                )
                and wf["id"] not in seen_workflow_ids
            ):
                seen_workflow_ids.add(wf["id"])
                valid_wfs.append(
                    {
                        "label": f"{wf['engine']['name']}/{wf['name']}",
                        "value": wf["id"],
                    }
                )

        logger.info(f"valid_wfs: {valid_wfs}")
        # Return the data and the first value if the data is not empty
        if valid_wfs:
            return valid_wfs, valid_wfs[0]["value"]
        else:
            return dash.no_update, dash.no_update

    @app.callback(
        Output({"type": "datacollection-selection-label", "index": MATCH}, "data"),
        Output({"type": "datacollection-selection-label", "index": MATCH}, "value"),
        State({"type": "workflow-selection-label", "index": MATCH}, "value"),
        State({"type": "workflow-selection-label", "index": MATCH}, "id"),
        Input({"type": "btn-option", "index": MATCH, "value": ALL}, "n_clicks"),
        State("local-store", "data"),
        State("url", "pathname"),
        prevent_initial_call=True,
    )
    def set_datacollection_options(selected_workflow, id, n_clicks, local_store, pathname):
        if not local_store:
            raise dash.exceptions.PreventUpdate

        TOKEN = local_store["access_token"]

        if isinstance(ctx.triggered_id, dict):
            if ctx.triggered_id["type"] == "btn-option":
                component_selected = ctx.triggered_id["value"]
        else:
            component_selected = "None"

        # Extract dashboard_id from pathname, handling both regular and component creation URLs
        # Regular: /dashboard/{dashboard_id}
        # Component creation: /dashboard/{dashboard_id}/{component_id}/create
        path_parts = pathname.strip("/").split("/")
        if len(path_parts) >= 2:
            dashboard_id = path_parts[1]  # Always the second part
        else:
            dashboard_id = path_parts[-1]  # Fallback to last part

        logger.info(f"ðŸ”„ STEPPER: Extracted dashboard_id: {dashboard_id} from pathname: {pathname}")

        project = httpx.get(
            f"{API_BASE_URL}/depictio/api/v1/projects/get/from_dashboard_id/{dashboard_id}",
            headers={
                "Authorization": f"Bearer {TOKEN}",
            },
        ).json()
        logger.info(f"Id: {id}")
        logger.info(f"Selected workflow: {selected_workflow}")
        all_wf_dc = project["workflows"]
        logger.info(f"All workflows and data collections: {all_wf_dc}")
        selected_wf_list = [wf for wf in all_wf_dc if wf["id"] == selected_workflow]
        logger.info(f"Selected workflow: {selected_wf_list}")

        if not selected_wf_list:
            logger.error(f"No workflow found with id '{selected_workflow}'")
            logger.error(f"Available workflow ids: {[wf['id'] for wf in all_wf_dc]}")
            return [], None

        selected_wf_data = selected_wf_list[0]

        mapping_component_data_collection = {
            "table": ["Figure", "Card", "Interactive", "Table", "Text"],
            "jbrowse2": ["JBrowse2"],
        }

        logger.info(f"Component selected: {component_selected}")

        # Get regular data collections
        valid_dcs = [
            {
                "label": dc["data_collection_tag"],
                "value": dc["id"],
            }
            for dc in selected_wf_data["data_collections"]
            if component_selected in mapping_component_data_collection[dc["config"]["type"]]
        ]

        # Add joined data collection options only for Figure and Table components
        # Exclude Card and Interactive components from having access to joined data collections
        allowed_components_for_joined = ["Figure", "Table"]
        if component_selected in allowed_components_for_joined:
            try:
                # Fetch available joins for this workflow
                joins_response = httpx.get(
                    f"{API_BASE_URL}/depictio/api/v1/datacollections/get_dc_joined/{selected_workflow}",
                    headers={"Authorization": f"Bearer {TOKEN}"},
                )

                if joins_response.status_code == 200:
                    joins_data = joins_response.json()
                    workflow_joins = joins_data.get(selected_workflow, {})

                    # Create a mapping from DC ID to DC tag for display names
                    dc_id_to_tag = {
                        dc["id"]: dc["data_collection_tag"]
                        for dc in selected_wf_data["data_collections"]
                    }

                    # Add joined DC options
                    for join_key, join_config in workflow_joins.items():
                        # Extract DC IDs from join key (format: "dc_id1--dc_id2")
                        dc_ids = join_key.split("--")
                        if len(dc_ids) == 2:
                            dc1_id, dc2_id = dc_ids
                            dc1_tag = dc_id_to_tag.get(dc1_id, dc1_id)
                            dc2_tag = dc_id_to_tag.get(dc2_id, dc2_id)

                            # Create display name for joined DC
                            joined_label = f"ðŸ”— Joined: {dc1_tag} + {dc2_tag}"

                            valid_dcs.append(
                                {
                                    "label": joined_label,
                                    "value": join_key,  # Use join key as value (e.g., "dc_id1--dc_id2")
                                }
                            )

                    logger.info(f"Added {len(workflow_joins)} joined data collection options")
                else:
                    logger.warning(
                        f"Failed to fetch joins for workflow {selected_workflow}: {joins_response.status_code}"
                    )

            except Exception as e:
                logger.error(f"Error fetching joined data collections: {str(e)}")

        logger.info(f"ID: {id}")
        logger.info(f"Total valid DCs (including joins): {len(valid_dcs)}")

        if not selected_workflow:
            raise dash.exceptions.PreventUpdate

        # Return the data and the first value if the data is not empty
        if valid_dcs:
            return valid_dcs, valid_dcs[0]["value"]
        else:
            raise dash.exceptions.PreventUpdate

    @app.callback(
        [
            Output({"type": "stepper-basic-usage", "index": MATCH}, "active"),
            Output({"type": "next-basic-usage", "index": MATCH}, "disabled"),
        ],
        [
            Input({"type": "back-basic-usage", "index": MATCH}, "n_clicks"),
            Input({"type": "next-basic-usage", "index": MATCH}, "n_clicks"),
            Input({"type": "workflow-selection-label", "index": MATCH}, "value"),
            Input({"type": "datacollection-selection-label", "index": MATCH}, "value"),
            Input({"type": "btn-option", "index": MATCH, "value": ALL}, "n_clicks"),
        ],
        [State({"type": "stepper-basic-usage", "index": MATCH}, "active")],
    )
    def update_stepper(
        back_clicks,
        next_clicks,
        workflow_selection,
        data_selection,
        btn_option_clicks,
        current_step,
    ):
        ctx = dash.callback_context

        if not ctx.triggered:
            # No inputs have fired yet, prevent update
            raise dash.exceptions.PreventUpdate

        triggered_id = ctx.triggered_id
        if isinstance(ctx.triggered_id, dict):
            triggered_input = ctx.triggered_id["type"]
        elif isinstance(ctx.triggered_id, str):
            triggered_input = ctx.triggered_id
        inputs_list = ctx.inputs_list

        logger.info(f"CTX triggered: {ctx.triggered}")
        logger.info(f"Triggered ID: {triggered_id}")
        logger.info(f"Inputs list: {inputs_list}")

        next_step = current_step  # Default to the current step if no actions require a change

        # Check if any btn-option was clicked
        btn_clicks = [btn for btn in btn_option_clicks if btn > 0]
        if btn_clicks:
            # Check if Text component was selected
            if isinstance(triggered_id, dict) and triggered_id.get("type") == "btn-option":
                component_selected = triggered_id.get("value")
                logger.info(f"Component selected: {component_selected}")
                if component_selected == "Text":
                    # Text components don't need data selection, skip to design step
                    next_step = 2  # Move directly to component design step
                    logger.info(f"Text component selected, advancing to step {next_step}")
                    return next_step, False  # Return immediately to avoid further processing
                else:
                    # Other components need data selection
                    next_step = 1  # Move from button selection to data selection
            else:
                next_step = 1  # Default: move to data selection

        if triggered_input == "btn-option":
            if not btn_clicks:
                return current_step, True

        # Check workflow and data collection for enabling/disabling the next button
        disable_next = False
        if current_step == 1 and (not workflow_selection or not data_selection):
            disable_next = True

        # Check if the Next or Back buttons were clicked
        if "next-basic-usage" in triggered_input:
            next_step = min(3, current_step + 1)  # Move to the next step, max out at step 3
        elif "back-basic-usage" in triggered_input:
            next_step = max(0, current_step - 1)  # Move to the previous step, minimum is step 0

        return next_step, disable_next

    # Data preview callback for stepper
    @app.callback(
        Output({"type": "stepper-data-preview", "index": MATCH}, "children"),
        [
            Input({"type": "workflow-selection-label", "index": MATCH}, "value"),
            Input({"type": "datacollection-selection-label", "index": MATCH}, "value"),
        ],
        [
            State("local-store", "data"),
            State("theme-store", "data"),
        ],
        prevent_initial_call=True,
    )
    def update_stepper_data_preview(workflow_id, data_collection_id, local_data, theme):
        """Update data preview in stepper when workflow/data collection changes."""
        if not workflow_id or not data_collection_id or not local_data:
            return html.Div()

        try:
            TOKEN = local_data["access_token"]

            # Load data preview (first 100 rows for stepper)
            df = load_deltatable_lite(
                workflow_id=workflow_id,
                data_collection_id=data_collection_id,
                TOKEN=TOKEN,
                limit_rows=100,  # Default preview size for stepper
                load_for_preview=True,  # Use preview cache to avoid conflicts with full dataset
            )

            if df is None or df.height == 0:
                return dmc.Alert(
                    "No data available for preview",
                    color="yellow",
                    title="No Data",
                )

            # Convert to pandas for AG Grid
            df_pd = df.to_pandas()

            # Handle column names with dots
            column_mapping = {}
            for col in df_pd.columns:
                if "." in col:
                    safe_col_name = col.replace(".", "_")
                    column_mapping[col] = safe_col_name
                else:
                    column_mapping[col] = col

            # Rename DataFrame columns to safe names
            df_pd = df_pd.rename(columns=column_mapping)

            # Create column definitions with improved styling
            column_defs = []
            original_columns = list(column_mapping.keys())
            for original_col in original_columns:
                safe_col = column_mapping[original_col]

                col_def = {
                    "headerName": original_col,
                    "field": safe_col,
                    "filter": True,
                    "sortable": True,
                    "resizable": True,
                    "minWidth": 120,
                }

                # Set appropriate column types
                if df_pd[safe_col].dtype in ["int64", "float64"]:
                    col_def["type"] = "numericColumn"
                elif df_pd[safe_col].dtype == "bool":
                    col_def["cellRenderer"] = "agCheckboxCellRenderer"

                column_defs.append(col_def)

            # Create enhanced AG Grid for stepper
            grid = dag.AgGrid(
                id={"type": "stepper-data-grid", "index": workflow_id},
                columnDefs=column_defs,
                rowData=df_pd.to_dict("records"),
                defaultColDef={
                    "filter": True,
                    "sortable": True,
                    "resizable": True,
                    "minWidth": 100,
                },
                dashGridOptions={
                    "pagination": True,
                    "paginationPageSize": 10,  # Smaller page size for stepper
                    "domLayout": "normal",
                    "animateRows": True,
                    "suppressMenuHide": True,
                },
                style={"height": "350px", "width": "100%"},
                className=_get_ag_grid_theme_class(theme),
            )

            # Create summary and controls
            summary_controls = dmc.Group(
                [
                    dmc.Group(
                        [
                            DashIconify(icon="mdi:table-eye", width=20, color="#228be6"),
                            dmc.Text("Data Preview", fw="bold", size="md"),
                        ],
                        gap="xs",
                    ),
                    dmc.Group(
                        [
                            dmc.Text(
                                f"Showing {min(100, df.height):,} of {df.height:,} rows",
                                size="sm",
                                c="gray",
                            ),
                            dmc.Text(f"{df.width} columns", size="sm", c="gray"),
                        ],
                        gap="lg",
                    ),
                ],
                justify="space-between",
                align="center",
            )

            return dmc.Card(
                [
                    summary_controls,
                    dmc.Space(h="sm"),
                    grid,
                ],
                withBorder=True,
                shadow="sm",
                radius="md",
                p="md",
            )

        except Exception as e:
            logger.error(f"Error in stepper data preview: {e}")
            return dmc.Alert(
                f"Error loading data preview: {str(e)}",
                color="red",
                title="Preview Error",
            )


def create_stepper_output_edit(n, parent_id, active, component_data, TOKEN):
    # logger.info(f"Component data: {component_data}")
    id = {"type": f"{component_data['component_type']}-component", "index": n}

    # wf_tag = return_wf_tag_from_id(component_data["wf_id"], TOKEN=TOKEN)
    # dc_tag = return_dc_tag_from_id(
    #     # workflow_id=component_data["wf_id"],
    #     data_collection_id=component_data["dc_id"],
    #     TOKEN=TOKEN,
    # )

    select_row = dmc.SimpleGrid(
        cols=2,
        spacing="md",
        children=[
            dmc.Select(
                id={"type": "workflow-selection-label", "index": n},
                value=component_data.get("wf_id", ""),
                label=dmc.Group(
                    [
                        DashIconify(icon="flat-color-icons:workflow", width=20),
                        dmc.Text("Workflow selection", fw="bold", size="md"),
                    ],
                    gap="xs",
                ),
                placeholder="Select workflow...",
            ),
            dmc.Select(
                id={
                    "type": "datacollection-selection-label",
                    "index": n,
                },
                value=component_data.get("dc_id", ""),
                label=dmc.Group(
                    [
                        DashIconify(icon="bxs:data", width=20),
                        dmc.Text("Data collection selection", fw="bold", size="md"),
                    ],
                    gap="xs",
                ),
                placeholder="Select data collection...",
            ),
        ],
        style={"display": "none"},
    )

    # logger.info(f"Select row: {select_row}")

    # Defensive handling for missing wf_id/dc_id
    wf_id = component_data.get("wf_id")
    dc_id = component_data.get("dc_id")

    if wf_id and dc_id:
        df = load_deltatable_lite(wf_id, dc_id, TOKEN=TOKEN)
    else:
        logger.warning(f"Missing wf_id or dc_id in component_data: wf_id={wf_id}, dc_id={dc_id}")
        # Return empty dataframe as fallback
        import polars as pl

        df = pl.DataFrame()
    # logger.info(f"DF: {df}")

    def return_design_component(component_selected, id, df):
        if component_selected == "Figure":
            return design_figure(id, component_data=component_data)
        elif component_selected == "Card":
            return design_card(id, df)
        elif component_selected == "Interactive":
            return design_interactive(id, df)
        # elif component_selected == "Table":
        #     return design_table(id)

    component_selected = component_data["component_type"].capitalize()
    card = return_design_component(component_selected=component_selected, id=id, df=df)
    # logger.info(f"Card: {card}")

    # Handle the fact that design functions return lists, not single components
    if isinstance(card, list):
        modal_body = dmc.Stack([select_row] + card, gap="md", style={"width": "100%"})
    else:
        modal_body = dmc.Stack([select_row, card], gap="md", style={"width": "100%"})

    modal = dmc.Modal(
        id={"type": "modal-edit", "index": n},
        children=[
            dmc.Stack(
                [
                    html.Div(
                        modal_body,
                        style=MODAL_BODY_STYLE,
                    ),
                    dmc.Paper(
                        dmc.Group(
                            [
                                dmc.Button(
                                    "Confirm Edit",
                                    id={"type": "btn-done-edit", "index": n},
                                    n_clicks=0,
                                    size="lg",
                                    leftSection=DashIconify(icon="bi:check-circle", width=20),
                                    color="green",
                                    disabled=True,
                                ),
                            ],
                            justify="center",
                        ),
                        style=MODAL_FOOTER_STYLE,
                        withBorder=True,
                    ),
                ],
                style=MODAL_CONTENT_STYLE,
                gap=0,
            )
        ],
        title=html.Div(
            [
                html.Img(
                    src=dash.get_asset_url("images/icons/favicon.ico"),
                    style={
                        "height": "34px",
                        "width": "34px",
                        "marginRight": "10px",
                        "verticalAlign": "middle",
                    },
                ),
                html.Span("Edit your dashboard component", style={"verticalAlign": "middle"}),
            ]
        ),
        opened=True,
        size=MODAL_CONFIG["size"],
        centered=True,
        withCloseButton=True,
        closeOnClickOutside=True,
        closeOnEscape=True,
        trapFocus=False,  # Fix DMC Switch clickability in modals
        styles={
            "title": {
                "fontSize": "1.8rem",
                "fontWeight": "bold",
                "textAlign": "center",
                "width": "100%",
            },
            "header": {
                "justifyContent": "center",
                "textAlign": "center",
            },
        },
    )
    # logger.info(f"TEST MODAL: {modal}")

    return modal


def create_stepper_output(n, active):
    logger.info(f"Creating stepper output for index {n}")
    logger.info(f"Active step: {active}")

    # # Use component_data to pre-populate stepper if editing
    # component_selected = component_data.get("component_selected", "None") if component_data else "None"
    # workflow_selection = component_data.get("workflow_selection", "")
    # datacollection_selection = component_data.get("datacollection_selection", "")

    stepper_dropdowns = dmc.Stack(
        [
            # Component Selection Display
            dmc.Stack(
                [
                    dmc.Title(
                        "Select Data Source",
                        order=3,
                        ta="center",
                        fw="bold",
                        mb="xs",
                    ),
                    dmc.Text(
                        "Choose the workflow and data collection for your component",
                        size="sm",
                        c="gray",
                        ta="center",
                        mb="md",
                    ),
                ],
                gap="xs",
            ),
            # Selected Component Badge
            dmc.Group(
                [
                    dmc.Text(
                        "Selected Component:",
                        fw="bold",
                        size="md",
                    ),
                    html.Div(
                        id={"type": "component-selected", "index": n},
                        children=dmc.Badge(
                            "None",
                            size="lg",
                            variant="outline",
                            color="gray",
                        ),
                    ),
                ],
                justify="center",
                align="center",
                gap="sm",
            ),
            dmc.Divider(variant="solid"),
            # Data Selection
            dmc.Stack(
                [
                    # dmc.Title(
                    #     "Data Configuration",
                    #     order=4,
                    #     ta="left",
                    #     fw="normal",
                    #     size="md",
                    #     mb="sm",
                    # ),
                    dmc.SimpleGrid(
                        cols=2,
                        spacing="lg",
                        children=[
                            dmc.Select(
                                id={"type": "workflow-selection-label", "index": n},
                                label=dmc.Group(
                                    [
                                        DashIconify(icon="flat-color-icons:workflow", width=20),
                                        dmc.Text("Workflow", fw="bold", size="md"),
                                    ],
                                    gap="xs",
                                ),
                                placeholder="Select workflow...",
                                size="md",
                            ),
                            dmc.Select(
                                id={
                                    "type": "datacollection-selection-label",
                                    "index": n,
                                },
                                label=dmc.Group(
                                    [
                                        DashIconify(icon="bxs:data", width=20),
                                        dmc.Text("Data Collection", fw="bold", size="md"),
                                    ],
                                    gap="xs",
                                ),
                                placeholder="Select data collection...",
                                size="md",
                            ),
                        ],
                    ),
                ],
                gap="sm",
            ),
            # Data Collection Information
            html.Div(id={"type": "dropdown-output", "index": n}),
            # Data Preview Section
            html.Div(id={"type": "stepper-data-preview", "index": n}),
        ],
        gap="lg",
    )

    buttons_list = html.Div(
        [
            html.Div(
                id={
                    "type": "buttons-list",
                    "index": n,
                }
            ),
            html.Div(
                id={
                    "type": "store-list",
                    "index": n,
                }
            ),
        ]
    )

    step_one = dmc.StepperStep(
        label="Component Type",
        description="Choose the type of dashboard component to create",
        children=buttons_list,
        id={"type": "stepper-step-2", "index": n},
    )

    step_two = dmc.StepperStep(
        label="Data Source",
        description="Connect your component to data",
        children=stepper_dropdowns,
        id={"type": "stepper-step-1", "index": n},
    )
    step_three = dmc.StepperStep(
        label="Component Design",
        description="Customize the appearance and behavior of your component",
        children=html.Div(
            id={
                "type": "output-stepper-step-3",
                "index": n,
            },
        ),
        id={"type": "stepper-step-3", "index": n},
    )
    step_completed = dmc.StepperCompleted(
        children=[
            dmc.Stack(
                [
                    dmc.Title(
                        "Component Ready!",
                        order=2,
                        ta="center",
                        fw="bold",
                        c="green",
                    ),
                    dmc.Text(
                        "Your component has been configured and is ready to be added to your dashboard.",
                        size="md",
                        ta="center",
                        c="gray",
                        mb="xl",
                    ),
                    dmc.Center(
                        dmc.Button(
                            "Add to Dashboard",
                            id={
                                "type": "btn-done",
                                "index": n,
                            },
                            color="green",
                            variant="filled",
                            n_clicks=0,
                            size="xl",
                            style={
                                "height": "60px",
                                "fontSize": "18px",
                                "fontWeight": "bold",
                            },
                            leftSection=DashIconify(icon="bi:check-circle", width=24),
                        )
                    ),
                    # Component metadata display
                    html.Div(
                        id={
                            "type": "component-metadata-display",
                            "index": n,
                        },
                        style={"marginTop": "2rem"},
                    ),
                ],
                gap="md",
                align="center",
            ),
        ],
    )

    steps = [step_one, step_two, step_three, step_completed]

    stepper = dmc.Stepper(
        id={"type": "stepper-basic-usage", "index": n},
        active=active,
        children=steps,
        color="gray",
        size="lg",
        iconSize=42,
        styles={
            "stepLabel": {
                "fontSize": "16px",
                "fontWeight": "bold",
            },
            "stepDescription": {
                "fontSize": "14px",
                "color": "var(--mantine-color-dimmed)",
            },
        },
    )

    stepper_footer = dmc.Group(
        justify="center",
        align="center",
        children=[
            dmc.Button(
                "Back",
                id={"type": "back-basic-usage", "index": n},
                variant="outline",
                color="gray",
                size="lg",
                n_clicks=0,
                leftSection=DashIconify(icon="mdi:arrow-left", width=20),
            ),
            dmc.Button(
                "Next Step",
                id={"type": "next-basic-usage", "index": n},
                variant="filled",
                disabled=True,
                n_clicks=0,
                color="gray",
                size="lg",
                rightSection=DashIconify(icon="mdi:arrow-right", width=20),
            ),
        ],
    )

    modal = html.Div(
        [
            dmc.Modal(
                id={"type": "modal", "index": n},
                children=[
                    dmc.Stack(
                        [
                            html.Div(
                                stepper,
                                style=MODAL_BODY_STYLE,
                            ),
                            dmc.Paper(
                                stepper_footer,
                                style=MODAL_FOOTER_STYLE,
                                withBorder=True,
                            ),
                        ],
                        style={
                            **MODAL_CONTENT_STYLE,
                            "marginTop": "-7px",  # Negative margin to move title closer to top
                        },
                        gap=0,
                    )
                ],
                title=html.Div(
                    [
                        html.Img(
                            src=dash.get_asset_url("images/icons/favicon.ico"),
                            style={
                                "height": "34px",
                                "width": "34px",
                                "marginRight": "10px",
                                "verticalAlign": "middle",
                            },
                        ),
                        html.Span("Create Dashboard Component", style={"verticalAlign": "middle"}),
                    ]
                ),
                opened=True,
                size=MODAL_CONFIG["size"],
                centered=False,  # Don't center for fullscreen
                withCloseButton=False,
                closeOnClickOutside=False,
                closeOnEscape=False,
                trapFocus=False,  # Fix DMC Switch clickability in modals
                fullScreen=True,
                styles={
                    "title": {
                        "fontSize": "1.8rem",
                        "fontWeight": "bold",
                        "textAlign": "center",
                        "width": "100%",
                    },
                    "header": {
                        "justifyContent": "center",
                        "textAlign": "center",
                    },
                },
            ),
        ],
        id=n,
    )
    # logger.info(f"TEST MODAL: {modal}")

    return modal


# Modal configuration constants
MODAL_CONFIG = {
    "size": "90%",
    "height": "100vh",  # Full height for fullscreen
}

# Modal styles for fullscreen mode
MODAL_CONTENT_STYLE = {
    "height": "100vh",  # Full viewport height
    "minHeight": "100vh",  # Ensure full height
    "maxHeight": "100vh",  # Prevent exceeding viewport
    "overflowY": "hidden",  # Prevent content scroll - let body handle it
    "padding": "0",  # Remove padding for fullscreen
    "display": "flex",
    "flexDirection": "column",
    "boxSizing": "border-box",
}

MODAL_BODY_STYLE = {
    "flex": "1",
    "overflowY": "auto",
    "overflowX": "hidden",  # Prevent horizontal scrolling
    "padding": "0.5rem 1rem 1rem 1rem",  # Reduced top padding
    "minHeight": "0",  # Allow flex item to shrink
    "boxSizing": "border-box",
    "marginBottom": "80px",  # Space for footer
}

MODAL_FOOTER_STYLE = {
    "flexShrink": "0",
    "padding": "1rem",
    "position": "fixed",  # Fixed to viewport
    "bottom": "0",
    "left": "0",
    "right": "0",
    "zIndex": "1000",
}


# Callback to dynamically control modal size
@callback(
    Output({"type": "modal-edit", "index": MATCH}, "size"),
    [Input({"type": "modal-edit", "index": MATCH}, "opened")],
    prevent_initial_call=True,
)
def update_modal_size(opened):
    """Update modal size when it opens."""
    return MODAL_CONFIG["size"]


@callback(
    Output({"type": "modal", "index": MATCH}, "size"),
    [Input({"type": "modal", "index": MATCH}, "opened")],
    prevent_initial_call=True,
)
def update_modal_size_regular(opened):
    """Update regular modal size when it opens."""
    return MODAL_CONFIG["size"]


@callback(
    Output({"type": "stepper-data-grid", "index": MATCH}, "className"),
    Input("theme-store", "data"),
    prevent_initial_call=False,
)
def update_ag_grid_theme(theme_data):
    """Update AG Grid theme class based on current theme."""
    return _get_ag_grid_theme_class(theme_data)
